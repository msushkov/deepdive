deepdive {
  
  db.default {
    driver: "org.postgresql.Driver"
    url: "jdbc:postgresql://localhost/"${DBNAME}
    user: ${PGUSER}
    password: ${PGPASSWORD}
  }

  # Put your variables here
  schema.variables {

    # entity linking
    el_candidate_link.is_correct: Boolean

    # relation extraction
    has_spouse.is_true: Boolean

  }

  # Put your extractors here
  extraction.extractors {
    
    # Do NLP processing on raw text (use sentences_dump.csv if want to skip this step)
    ext_sentences.before: ${APP_HOME}"/udf/clear_table.sh sentences"
    ext_sentences.input: """
        SELECT * FROM articles order by id asc
      """
    ext_sentences.output_relation: "sentences"
    ext_sentences.udf: 
      ${DEEPDIVE_HOME}"/util/nlp_extractor/run.sh -k articles.id -v articles.text -l 20 -t 4"
    ext_sentences.input_batch_size: 10
    ext_sentences.output_batch_size: 1000


    # Get PERSON mentions from the processed text
    ext_people.before: ${APP_HOME}"/udf/clear_table.sh person_mention"
    ext_people.input: """
        SELECT * FROM sentence
      """
    ext_people.output_relation: "person_mention"
    ext_people.udf: ${APP_HOME}"/udf/extract_people_mentions.py"
    ext_people.dependencies: ["ext_sentences"]


    ## ENTITY LINKING

    # Extract possible (entity, mention) pairs based on several predicates:
    # exact string match (lowercase); Levenshtein distance < 3;
    # if one of the strings is a subset of the other
    find_candidates.input: """
        SELECT * FROM person_mention AS m INNER JOIN entity AS e ON
        (lower(m.text_contents) = lower(e.text_contents)) OR 
        levenshtein(lower(m.text_contents), lower(e.text_contents)) < 3 OR
        position(lower(m.text_contents) in lower(e.text_contents)) >= 0 OR
        position(lower(e.text_contents) in lower(m.text_contents)) >= 0);
      """
    find_candidates.output_relation: "el_candidate_link"
    find_candidates.udf: ${APP_HOME}"/udf/entity-linking/extract_el_candidate_pairs.py"
    find_candidates.parallelism: 8
    find_candidates.dependencies: ["ext_people"]


    # Load the positive training examples
    load_positive_examples.input: """
        SELECT c.id AS "link_id" FROM positive_example AS p INNER JOIN mention AS m ON (p.text_contents = m.text_contents AND p.doc_id = m.doc_id)
        INNER JOIN candidate_link AS c ON m.id = c.mid AND p.eid = c.eid
      """
    load_positive_examples.output_relation: "evidence"
    load_positive_examples.udf: ${APP_HOME}"/udf/extract_positive_examples.py"
    load_positive_examples.parallelism: 4
    load_positive_examples.dependencies: ["find_candidates"]
    load_positive_examples.after: ${APP_HOME}"/util/el_insert_examples_into_candidate_table.sh"


    # Generate the negative examples
    generate_negative_examples.input: """
        SELECT c.id AS "link_id" FROM negative_example AS n INNER JOIN mention AS m ON (n.text_contents = m.text_contents AND n.doc_id = m.doc_id)
        INNER JOIN candidate_link AS c ON m.id = c.mid AND n.eid = c.eid;
      """
    generate_negative_examples.output_relation: "evidence"
    generate_negative_examples.udf: "examples/kbp/udf/generate_negative_examples.py"
    generate_negative_examples.parallelism: 4
    generate_negative_examples.dependencies: ["find_candidates"]


    # Extract features for (e, m) candidate pairs
    feature_extraction.before: "insert_examples_into_candidate_table.sh"
    feature_extraction.input: """
        SELECT * FROM candidate_link INNER JOIN mention 
        ON (candidate_link.mid = mention.id) INNER JOIN entity 
        ON (candidate_link.eid = entity.id);
      """
    feature_extraction.output_relation: "link_feature"
    feature_extraction.udf: "examples/kbp/udf/extract_features.py"
    feature_extraction.parallelism: 4
    feature_extraction.dependencies: ["load_positive_examples", "generate_negative_examples"]


    ### RELATION EXTRACTION    

    ext_has_spouse_candidates.before: ${APP_HOME}"/udf/clear_table.sh has_spouse"
    ext_has_spouse_candidates.input: """
        SELECT sentences.*, p1.id AS "p1.id", p1.text AS "p1.text", p2.id AS "p2.id", p2.text AS "p2.text" 
        FROM people_mentions p1, people_mentions p2, sentences 
        WHERE p1.sentence_id = p2.sentence_id AND p1.sentence_id = sentences.id AND p1.id != p2.id;
      """
    ext_has_spouse_candidates.output_relation: "has_spouse"
    ext_has_spouse_candidates.udf: ${APP_HOME}"/udf/ext_has_spouse.py"
    ext_has_spouse_candidates.dependencies: ["ext_people"]


    ext_has_spouse_features.before: ${APP_HOME}"/udf/clear_table.sh has_spouse_features"
    ext_has_spouse_features.input: """
        SELECT sentences.*, has_spouse.*, p1.start_position AS "p1.start_position", p1.length AS "p1.length", 
          p2.start_position AS "p2.start_position", p2.length AS "p2.length"
        FROM has_spouse, people_mentions p1, people_mentions p2, sentences
        WHERE has_spouse.person1_id = p1.id AND has_spouse.person2_id = p2.id 
          AND has_spouse.sentence_id = sentences.id;
      """
    ext_has_spouse_features.output_relation: "has_spouse_features"
    ext_has_spouse_features.udf: ${APP_HOME}"/udf/ext_has_spouse_features.py"
    ext_has_spouse_features.dependencies: ["ext_has_spouse_candidates"]

  }

  # Specify the logical rules
  inference.factors: {

    ## ENTITY LINKING

    # Unary factors for a given (e, m) variable, depending on the type of feature that was
    # extracted for the pair (e.g. edit distance)
    el_features.input_query: """
          SELECT * FROM link_feature AS f INNER JOIN candidate_link AS c ON
          (f.link_id = c.id)
        """
    el_features.function: "Imply(c.is_correct)"
    el_features.weight: "?(f.feature)"


    # A given mention can only link to 1 entity (no (e, m) pair with the same mid value can have
    # the same eid value).
    el_single_mention_to_one_entity.input_query: """
          SELECT * FROM
            (SELECT * FROM candidate_link AS l1, candidate_link AS l2 
            WHERE l1.mid = l2.mid AND l1.eid <> l2.eid) AS t 
            JOIN candidate_link AS c ON (t.l1.eid = c.eid AND t.l1.mid = c.mid)
        """
    el_single_mention_to_one_entityfunction: "Imply(c.is_correct)"
    el_single_mention_to_one_entityweight: 10


    ## RELATION EXTRACTION

    f_has_spouse_features.input_query: """SELECT * FROM has_spouse, has_spouse_features 
      WHERE has_spouse_features.relation_id = has_spouse.id"""
    f_has_spouse_features.function: "IsTrue(has_spouse.is_true)"
    f_has_spouse_features.weight: "?(has_spouse_features.feature)"

    f_has_spouse_symmetry.input_query: """
        SELECT r1.is_true AS "r1.is_true", r2.is_true AS "r2.is_true", r1.id AS "r1.id", r2.id AS "r2.id"
        FROM has_spouse r1, has_spouse r2 
        WHERE r1.person1_id = r2.person2_id AND r1.person2_id = r2.person1_id
      """
    f_has_spouse_symmetry.function: "Imply(has_spouse.r1.is_true, has_spouse.r2.is_true)"
    f_has_spouse_symmetry.weight: "?"

  }

  # specify which pipeline to run (pipeline defined below)
  #pipeline.run: "nonlp"
  pipeline.run: "nlp"

  pipeline.pipelines.nonlp: ["ext_people", "ext_has_spouse_candidates", "ext_has_spouse_features",
    "f_has_spouse_features", "f_has_spouse_symmetry"]

  pipeline.pipelines.nlp: ["ext_sentences"]

  # Specify a holdout fraction
  calibration.holdout_fraction: 0.25

}